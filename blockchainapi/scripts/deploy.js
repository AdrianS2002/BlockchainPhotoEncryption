const fs = require("fs");
const path = require("path");
const hre = require("hardhat");
require("dotenv").config();
const { ethers } = hre;

function compressUncompressedPubKey(uncompressed) {
  const hex = uncompressed.replace(/^0x/, "");
  if (hex.length !== 130 || !hex.startsWith("04")) {
    throw new Error("Public key necomprimat invalid");
  }
  const x = hex.slice(2, 66);
  const y = hex.slice(66);
  const yIsEven = (BigInt("0x" + y) % 2n) === 0n;
  const prefix = yIsEven ? "02" : "03";
  return "0x" + prefix + x;
}

function getPublicKeysFromPrivate(pk) {
  const priv = pk.startsWith("0x") ? pk : "0x" + pk;


  if (ethers.computePublicKey) {
    return {
      publicKey: ethers.computePublicKey(priv, false),         
      publicKeyCompressed: ethers.computePublicKey(priv, true),
    };
  }

  if (ethers.utils?.computePublicKey) {
    return {
      publicKey: ethers.utils.computePublicKey(priv, false),
      publicKeyCompressed: ethers.utils.computePublicKey(priv, true),
    };
  }
  
  const SigningKey = ethers.SigningKey || ethers.utils?.SigningKey;
  if (!SigningKey) throw new Error("Nu pot calcula public key (ethers v?).");
  const sk = new SigningKey(priv);
  return {
    publicKey: sk.publicKey, 
    publicKeyCompressed: compressUncompressedPubKey(sk.publicKey),
  };
}

function getMnemonic() {
  return (process.env.HARDHAT_MNEMONIC && process.env.HARDHAT_MNEMONIC.trim())
    || "test test test test test test test test test test test junk";
}

function deriveManyFromMnemonic(mnemonic, count) {
  const out = [];


  if (ethers.HDNodeWallet && ethers.Mnemonic) {
    const m = ethers.Mnemonic.fromPhrase(mnemonic);
    for (let i = 0; i < count; i++) {
      const w = ethers.HDNodeWallet.fromMnemonic(m, `m/44'/60'/0'/0/${i}`);
      const pk = w.privateKey;
      const pubs = getPublicKeysFromPrivate(pk);
      out.push({ index: i, address: w.address, privateKey: pk, ...pubs });
    }
    return out;
  }


  const root = ethers.utils.HDNode.fromMnemonic(mnemonic);
  for (let i = 0; i < count; i++) {
    const node = root.derivePath(`m/44'/60'/0'/0/${i}`);
    const w = new ethers.Wallet(node.privateKey);
    const pubs = getPublicKeysFromPrivate(node.privateKey);
    out.push({ index: i, address: w.address, privateKey: node.privateKey, ...pubs });
  }
  return out;
}


function parseAllowedFromEnvOr(wallets) {
  const raw = process.env.ALLOWED_ADDRESSES || "";
  const envList = raw.split(",").map(s => s.trim()).filter(Boolean);
  if (envList.length) return envList;
  return wallets.map(w => w.address);
}

function parseWeiFlexible(s, def = 0n) {
  if (!s || !String(s).trim()) return def;
  const v = String(s).trim().toLowerCase();
  if (v.endsWith("eth")) {
    const num = v.slice(0, -3);
    return ethers.parseEther(num);
  }
  return BigInt(v);
}

function writeEnvSection(lines) {
  const file = path.resolve(process.cwd(), ".env.local");

  const header = "# ---- BEGIN auto generated by deploy ----";
  const footer = "# ---- END auto generated by deploy ----";
  let base = "";
  if (fs.existsSync(file)) {
    base = fs.readFileSync(file, "utf8");
    base = base.replace(
      new RegExp(`${header}[\\s\\S]*?${footer}\\s*`, "m"),
      ""
    ).trimEnd();
  }
  const block = `${header}\n${lines.join("\n")}\n${footer}\n`;
  const content = (base ? base + "\n\n" : "") + block;
  fs.writeFileSync(file, content, "utf8");
  console.log(`.env.local actualizat -> ${file}`);
}

async function main() {
  const provider = ethers.provider;


  const nodeAddrs = await provider.send("eth_accounts", []);
  if (!Array.isArray(nodeAddrs) || nodeAddrs.length === 0) {
    throw new Error("eth_accounts a întors 0 adrese. Rulează întâi: npx hardhat node");
  }
  console.log(`Nodul are ${nodeAddrs.length} adrese.`);


  const COUNT = nodeAddrs.length;
  const derived = deriveManyFromMnemonic(getMnemonic(), COUNT);


  const mapDerived = new Map(derived.map(a => [a.address.toLowerCase(), a]));
  const wallets = nodeAddrs.map((addr, i) => {
    const d = mapDerived.get(addr.toLowerCase());
    if (!d) throw new Error(`Nu găsesc în derivare cheia pentru ${addr}. Verifică mnemonic-ul!`);
    return { index: i, ...d };
  });


  const deployer = new ethers.Wallet(wallets[0].privateKey, provider);
  const net = await provider.getNetwork();
  const bal = await provider.getBalance(deployer.address);
  console.log("ethers version:", ethers.version || "(unknown)");
  console.log("Network chainId:", Number(net.chainId));
  console.log("Deployer:", deployer.address);
  console.log("Balance (wei):", bal.toString());


  const allowed = parseAllowedFromEnvOr(wallets);
  const treasury = (process.env.TREASURY && process.env.TREASURY.trim()) || deployer.address;
  const sendFeeWei = parseWeiFlexible(process.env.SEND_FEE, 0n);     
  const decryptFeeWei = parseWeiFlexible(process.env.DECRYPT_FEE, 0n); 

  console.log("Treasury:", treasury);
  console.log("Allowed addresses:", allowed.length);
  console.log("sendFeeWei:", sendFeeWei.toString());
  console.log("decryptFeeWei:", decryptFeeWei.toString());


  const Factory = await ethers.getContractFactory("PhotoMailboxPayable", deployer);
  const contract = await Factory.deploy(treasury, sendFeeWei, decryptFeeWei, allowed);
  await contract.waitForDeployment();
  const contractAddress = await contract.getAddress();
  console.log("PhotoMailboxPayable deployed at:", contractAddress);

  const lines = [
    `CONTRACT_ADDRESS=${contractAddress}`,
    `ALLOWED_ADDRESSES=${allowed.join(",")}`,
    `HARDHAT_MNEMONIC="${getMnemonic()}"`,
    `TREASURY=${treasury}`,
    `SEND_FEE=${sendFeeWei.toString()}`,
    `DECRYPT_FEE=${decryptFeeWei.toString()}`,
  ];
  wallets.forEach(w => {
    lines.push(`ACCOUNT_${w.index}_ADDRESS=${w.address}`);
    lines.push(`ACCOUNT_${w.index}_PRIVATE_KEY=${w.privateKey}`);
    lines.push(`ACCOUNT_${w.index}_PUBLIC_KEY=${w.publicKey}`);
    lines.push(`ACCOUNT_${w.index}_PUBLIC_KEY_COMPRESSED=${w.publicKeyCompressed}`);
  });
  writeEnvSection(lines);

  const out = {
    chainId: Number(net.chainId),
    contract: contractAddress,
    treasury,
    fees: {
      sendFeeWei: sendFeeWei.toString(),
      decryptFeeWei: decryptFeeWei.toString(),
    },
    accounts: wallets
  };
  fs.writeFileSync(
    path.resolve(process.cwd(), "deploy-output.json"),
    JSON.stringify(out, null, 2),
    "utf8"
  );
  console.log("deploy-output.json scris.");

  const artifact = await hre.artifacts.readArtifact("PhotoMailboxPayable");
  const abiOut = {
    address: contractAddress,
    abi: artifact.abi
  };
  fs.writeFileSync(
    path.resolve(process.cwd(), "contract-abi.json"),
    JSON.stringify(abiOut, null, 2),
    "utf8"
  );
  console.log("contract-abi.json scris (address + abi).");
}

main().catch((e) => { console.error(e); process.exit(1); });
